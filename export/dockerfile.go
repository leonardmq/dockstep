package export

import (
	"fmt"
	"strings"

	"dockstep.dev/types"
)

// GenerateDockerfile generates a Dockerfile from project blocks
func GenerateDockerfile(project *types.Project, endBlockID string, opts types.DockerfileOptions) (string, error) {
	var lines []string

	// Find the end block
	var endBlock *types.Block
	if endBlockID == "" {
		// Use the last block
		if len(project.Blocks) == 0 {
			return "", fmt.Errorf("no blocks found")
		}
		endBlock = &project.Blocks[len(project.Blocks)-1]
	} else {
		// Find the specified block
		for i := range project.Blocks {
			if project.Blocks[i].ID == endBlockID {
				endBlock = &project.Blocks[i]
				break
			}
		}
		if endBlock == nil {
			return "", fmt.Errorf("block %s not found", endBlockID)
		}
	}

	// Build dependency chain
	chain, err := buildBlockChain(project.Blocks, endBlock.ID)
	if err != nil {
		return "", fmt.Errorf("failed to build block chain: %w", err)
	}

	// Generate Dockerfile
	lines = append(lines, "# Generated by dockstep")
	lines = append(lines, "")

	// Add FROM directive for the first block
	if len(chain) > 0 {
		firstBlock := chain[0]
		if firstBlock.From != "" {
			lines = append(lines, fmt.Sprintf("FROM %s", firstBlock.From))
		} else {
			return "", fmt.Errorf("first block must have 'from' specified")
		}
		lines = append(lines, "")
	}

	// Process each block in the chain
	for i, block := range chain {
		// Add block instructions directly
		for _, instruction := range block.Instructions {
			lines = append(lines, instruction)
		}
		if len(block.Instructions) > 0 {
			lines = append(lines, "")
		}

		// Add export configuration if present
		if block.Export != nil {
			// Add labels
			if len(block.Export.Labels) > 0 {
				for key, value := range block.Export.Labels {
					lines = append(lines, fmt.Sprintf("LABEL %s=%s", key, value))
				}
				lines = append(lines, "")
			}

			// Add entrypoint
			if len(block.Export.Entrypoint) > 0 {
				entrypoint := strings.Join(block.Export.Entrypoint, " ")
				lines = append(lines, fmt.Sprintf("ENTRYPOINT [%s]", entrypoint))
				lines = append(lines, "")
			}

			// Add cmd
			if len(block.Export.Cmd) > 0 {
				cmd := strings.Join(block.Export.Cmd, " ")
				lines = append(lines, fmt.Sprintf("CMD [%s]", cmd))
				lines = append(lines, "")
			}
		}

		// Add stage name if this is not the last block
		if i < len(chain)-1 {
			lines = append(lines, fmt.Sprintf("# Stage: %s", block.ID))
			lines = append(lines, "")
		}
	}

	return strings.Join(lines, "\n"), nil
}

// buildBlockChain builds the dependency chain for a block
func buildBlockChain(blocks []types.Block, endBlockID string) ([]types.Block, error) {
	// Create a map of block ID to block
	blockMap := make(map[string]types.Block)
	for _, block := range blocks {
		blockMap[block.ID] = block
	}

	// Build the chain by following dependencies
	var chain []types.Block
	visited := make(map[string]bool)

	var buildChain func(blockID string) error
	buildChain = func(blockID string) error {
		if visited[blockID] {
			return fmt.Errorf("circular dependency detected")
		}
		visited[blockID] = true

		block, exists := blockMap[blockID]
		if !exists {
			return fmt.Errorf("block %s not found", blockID)
		}

		// Add parent blocks first
		if block.FromBlock != "" {
			if err := buildChain(block.FromBlock); err != nil {
				return err
			}
		}

		// Add this block
		chain = append(chain, block)
		return nil
	}

	if err := buildChain(endBlockID); err != nil {
		return nil, err
	}

	return chain, nil
}
