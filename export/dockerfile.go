package export

import (
	"fmt"
	"strings"

	"dockstep.dev/types"
)

// GenerateDockerfile generates a Dockerfile from project blocks
func GenerateDockerfile(project *types.Project, endBlockID string, opts types.DockerfileOptions) (string, error) {
	var lines []string

	// Find the end block
	var endBlock *types.Block
	if endBlockID == "" {
		// Use the last block
		if len(project.Blocks) == 0 {
			return "", fmt.Errorf("no blocks found")
		}
		endBlock = &project.Blocks[len(project.Blocks)-1]
	} else {
		// Find the specified block
		for i := range project.Blocks {
			if project.Blocks[i].ID == endBlockID {
				endBlock = &project.Blocks[i]
				break
			}
		}
		if endBlock == nil {
			return "", fmt.Errorf("block %s not found", endBlockID)
		}
	}

	// Build dependency chain
	chain, err := buildBlockChain(project.Blocks, endBlock.ID)
	if err != nil {
		return "", fmt.Errorf("failed to build block chain: %w", err)
	}

	// Generate Dockerfile
	lines = append(lines, "# Generated by dockstep")
	lines = append(lines, "")

	// Add FROM directive for the first block
	if len(chain) > 0 {
		firstBlock := chain[0]
		if firstBlock.From != "" {
			lines = append(lines, fmt.Sprintf("FROM %s", firstBlock.From))
		} else {
			return "", fmt.Errorf("first block must have 'from' specified")
		}
		lines = append(lines, "")
	}

	// Process each block in the chain
	for i, block := range chain {
		// Add environment variables
		if len(block.Env) > 0 {
			for _, env := range block.Env {
				lines = append(lines, fmt.Sprintf("ENV %s", env))
			}
			lines = append(lines, "")
		}

		// Add working directory
		if block.Workdir != "" {
			lines = append(lines, fmt.Sprintf("WORKDIR %s", block.Workdir))
			lines = append(lines, "")
		}

		// Process commands - separate COPY from RUN
		if block.Cmd != "" {
			cmdLines := strings.Split(strings.TrimSpace(block.Cmd), "\n")
			var copyLines []string
			var runLines []string
			
			// Separate COPY and RUN commands
			for _, line := range cmdLines {
				line = strings.TrimSpace(line)
				if line == "" {
					continue
				}
				if strings.HasPrefix(strings.ToUpper(line), "COPY") {
					copyLines = append(copyLines, line)
				} else {
					runLines = append(runLines, line)
				}
			}
			
			// Add COPY directives
			for _, copyLine := range copyLines {
				lines = append(lines, copyLine)
			}
			if len(copyLines) > 0 {
				lines = append(lines, "")
			}
			
			// Add RUN directive for non-COPY commands
			if len(runLines) > 0 {
				if len(runLines) == 1 {
					// Single line command
					lines = append(lines, fmt.Sprintf("RUN %s", runLines[0]))
				} else {
					// Multi-line command
					lines = append(lines, "RUN \\")
					for j, line := range runLines {
						if j == len(runLines)-1 {
							lines = append(lines, fmt.Sprintf("    %s", line))
						} else {
							lines = append(lines, fmt.Sprintf("    %s && \\", line))
						}
					}
				}
				lines = append(lines, "")
			}
		}

		// Add export configuration if present
		if block.Export != nil {
			// Add labels
			if len(block.Export.Labels) > 0 {
				for key, value := range block.Export.Labels {
					lines = append(lines, fmt.Sprintf("LABEL %s=%s", key, value))
				}
				lines = append(lines, "")
			}

			// Add entrypoint
			if len(block.Export.Entrypoint) > 0 {
				entrypoint := strings.Join(block.Export.Entrypoint, " ")
				lines = append(lines, fmt.Sprintf("ENTRYPOINT [%s]", entrypoint))
				lines = append(lines, "")
			}

			// Add cmd
			if len(block.Export.Cmd) > 0 {
				cmd := strings.Join(block.Export.Cmd, " ")
				lines = append(lines, fmt.Sprintf("CMD [%s]", cmd))
				lines = append(lines, "")
			}
		}

		// Add stage name if this is not the last block
		if i < len(chain)-1 {
			lines = append(lines, fmt.Sprintf("# Stage: %s", block.ID))
			lines = append(lines, "")
		}
	}

	return strings.Join(lines, "\n"), nil
}

// buildBlockChain builds the dependency chain for a block
func buildBlockChain(blocks []types.Block, endBlockID string) ([]types.Block, error) {
	// Create a map of block ID to block
	blockMap := make(map[string]types.Block)
	for _, block := range blocks {
		blockMap[block.ID] = block
	}

	// Build the chain by following dependencies
	var chain []types.Block
	visited := make(map[string]bool)

	var buildChain func(blockID string) error
	buildChain = func(blockID string) error {
		if visited[blockID] {
			return fmt.Errorf("circular dependency detected")
		}
		visited[blockID] = true

		block, exists := blockMap[blockID]
		if !exists {
			return fmt.Errorf("block %s not found", blockID)
		}

		// Add parent blocks first
		if block.FromBlock != "" {
			if err := buildChain(block.FromBlock); err != nil {
				return err
			}
		}

		// Add this block
		chain = append(chain, block)
		return nil
	}

	if err := buildChain(endBlockID); err != nil {
		return nil, err
	}

	return chain, nil
}
